Задача: Сообщения с JWT аутентификацией пользователя
   =

---------------------------------------------------------------------------------------------------

В БД создать пару sql табличек со связями (foreign keys)
Сделать HTTP POST эндпоинт, который получает данные в json вида:\
{\
name: "имя отправителя"\
password: "пароль"\
}\
этот эндпоинт проверяет пароль по БД и создает jwt токен (срок действия токена и алгоритм подписи не принципиален, для генерации и работе с токеном можно использовать готовую библиотечку) в токен записывает данные: name: "имя отправителя"
и отправляет токен в ответ, тоже json вида:\
{\
token: "тут сгенерированный токен"\
}\
Сервер слушает и отвечает в какой-нибудь эндпоинт, в него на вход поступают данные в формате json:
Сообщения клиента-пользователя:\
{\
name:       "имя отправителя",\
message:    "текст сообщение"\
}\
В заголовках указан Bearer токен, полученный из эндпоинта выше.
Проверить токен, в случае успешной проверки токена, полученное сообщение сохранить в БД.
Если пришло сообщение вида:\
{\
name:       "имя отправителя",\
message:    "history 10"\
}\
проверить токен, в случае успешной проверки токена отправить отправителю 10 последних сообщений из БД.
Покрыть код тестами.

##   ---------  Описание приложения  --------

Разработка и внедрение REST API используя: Spring-Boot 2.6/ Hibernate/ JDK 17/Spring Data JPA/Spring Security/H2 /Swagger Open Api/ Json Jackson

### Все необходимое для запуска и тестирования приложения:

-----------------
1. Запуск приложения через `mvn spring-boot:run`\
  или нажав Run в MessagesRestApplication классе
2. Тестирование, curl запросы - через [**SWAGGER**](http://localhost:8080/swagger-ui.html) 
3. Просмотр данных в H2(in memory) базе после подключения к ней `DataSource -> H2`:\
   username: sa\
   password:\
   URL: jdbc:h2:tcp://localhost:9092/mem:messages

Тестовые креденшелы (хранятся в H2 базе) вводим в [**SWAGGER**](http://localhost:8080/swagger-ui.html):
```
Admin: admin@gmail.com / admin
User:  user@yandex.ru / password
Guest: guest@gmail.com / guest
```
-----------------
Tomcat server port сделал: 8081.\
Swagger: используем scheme = "bearer" для установки header="Authorization" значения: "Bearer " + generatedToken.\
Файл с curl запросами не прикладывал. Мне кажется Swagger'а для тестов вполне достаточно. Curl запросы там есть для 
каждого запроса контроллера. Swagger удобный, красивый и не тормозит как SoapUI.
### AuthenticationController
- После старта приложения необходимо произвести аутентификацию пользователя, иначе все запросы завершатся со статусом: 
`401 "Unauthorized"`. Аутентификация производится по эндпоинту `POST: /api/authentication/login`. Доступ к эндпоинту 
имеют все(Authorized/Unauthorized) - permitAll(). После успешной аутентификации получаем в ответе token, который 
необходим для дальнейшей работы с приложением. Поэтому, копируем token(без кавычек), вверху справа в меню Swagger 
нажимаем кнопку `Authorize` и вставляем token в пустое поле, опять нажимаем Autorize. Все - можно тестировать остальные 
методы контроллеров. Теперь при дальнейших запросах клиент будет посылать на сервер этот token, а сервер будет
производить процесс авторизации пользователя по этому токену через фильтр `JWTAuthorizationFilter`, который включается
в Security конфигурацию в классе `WebSecurity`.
- Регистрация нового пользователя по эндпоинту `POST: /api/authentication/register`. Доступ к эндпоинту только для
не аутентифицированных пользователей - anonymous().

### ProfileController
Контроллер для управления пользователя своим аккаунтом. Имеет эндпоинт `/api/profile` с методами `GET, PUT, DELETE`.

### MessageController
Контроллер для управления сообщениями пользователя. Имеет эндпоинт `/api/messages/{id}` с методами `GET, DELETE`.\
Основной эндпоинт для задания - `POST: /api/messages` находится в методе `List<Message> saveOrGetLast()`. Этот метод
принимает body JSON как указано в задании:\
{\
name:       "имя отправителя",\
message:    "текст сообщение"\
}\
Из этого body JSON собирается объект Message.\
Далее в классе `MessageService` происходит бизнес логика по нашему заданию: сохранение Message, либо возврат 10 
последних Message.

### Модель: Message
Swagger для Message настроен под задание - отображает необходимые поля Entity(name, message) для отправки body Json.\
Аннотации `@JsonInclude(JsonInclude.Include.NON_EMPTY)` в основном использовал для запросов в тестах, чтобы сериализовать 
только требуемые(not null) по заданию поля(name, message) в body Json.

### Модель: AuthenticationRequest
Класс для сборки из body Json:\
{\
name:       "имя отправителя",\
message:    "текст сообщение"\
}\
при запросе на `POST: /api/authentication/login` в объект с полями:
- String name: - это Email пользователя, а не его имя, т.к. Email уникален.
- String password: - это пароль пользователя

### Модель: AuthenticationResponse
Класс для отправки в Json на клиент его токена:\
{\
token: "тут сгенерированный токен"\
}

### MessageRepository
Для метода List<Message> getLast() в @Query использую `nativeQuery = true`, тк JPQL не поддерживает LIMIT.
### Тесты
- Использовал в тестах прикрепление токена в header запроса через:\
`.secure(true)
.header(HttpHeaders.AUTHORIZATION, token(user))`
- Сравнение объектов через `assertThat(a).usingRecursiveComparison()` библиотеки `assertj.core.api`, где сравнение 
объектов идет по их полям не через equals от Entity, а через equals библиотеи `assertj.core.api`. 
- тесты основного метода `List<Message> saveOrGetLast()`:
  1. тест проверки создания нового сообщения Message:
     `void createMessageSaveOrGetLast()`
  2. тест проверки на возврат 10 Message:
     `returnMessagesSaveOrGetLast()`